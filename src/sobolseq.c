/* Copyright (c) 2007 Massachusetts Institute of Technology
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

/* Generation of Sobol sequences in up to 1111 dimensions, based on the
   algorithms described in:
   P. Bratley and B. L. Fox, Algorithm 659, ACM Trans.
   Math. Soft. 14 (1), 88-100 (1988),
   as modified by:
   S. Joe and F. Y. Kuo, ACM Trans. Math. Soft 29 (1), 49-57 (2003).

   Note that the code below was written without even looking at the
   Fortran code from the TOMS paper, which is only semi-free (being
   under the restrictive ACM copyright terms).  Then I went to the
   Fortran code and took out the table of primitive polynomials and
   starting direction #'s ... since this is just a table of numbers
   generated by a deterministic algorithm, it is not copyrightable.
   (Obviously, the format of these tables then necessitated some
   slight modifications to the code.)

   For the test integral of Joe and Kuo (see the main() program
   below), I get exactly the same results for integrals up to 1111
   dimensions compared to the table of published numbers (to the 5
   published significant digits).

   This is not to say that the authors above should not be credited for
   their clear description of the algorithm (and their tabulation of
   the critical numbers).  Please cite them.  Just that I needed
   a free/open-source implementation. */

#include <stdlib.h>
#include <math.h>
#include <stdint.h>
#include "sobolseq.h"
#include "soboldata.h"


/* Return position (0, 1, ...) of rightmost (least-significant) zero bit in n.
 *
 * This code uses a 32-bit version of algorithm to find the rightmost
 * one bit in Knuth, _The Art of Computer Programming_, volume 4A
 * (draft fascicle), section 7.1.3, "Bitwise tricks and
 * techniques."
 *
 * Assumes n has a zero bit, i.e. n < 2^32 - 1.
 *
 */
static unsigned rightzero32(uint32_t n)
{
#if defined(__GNUC__) &&											\
		((__GNUC__ == 3 && __GNUC_MINOR__ >= 4) || __GNUC__ > 3)
		return __builtin_ctz(~n);   /* gcc builtin for version >= 3.4 */
#else
		const uint32_t a = 0x05f66a47;      /* magic number, found by brute force */
		static const unsigned decode[32] = { 0, 1, 2, 26, 23, 3, 15, 27, 24, 21, 19, 4, 12, 16, 28, 6, 31, 25, 22, 14, 20, 18, 11, 5, 30, 13, 17, 10, 29, 9, 8, 7 };
		n = ~n;                     /* change to rightmost-one problem */
#ifdef _MSC_VER
#pragma warning(suppress:4146)
		n = a * (n & (-n)); /* same as below, but suppress spurious warning/error with MS compiler about negating unsigned int */
#else
		n = a * (n & (-n)); /* store in n to make sure mult. is 32 bits */
#endif
		return decode[n >> 27];
#endif
}

/* generate the next term x_{n+1} in the Sobol sequence, as an array
   x[sdim] of numbers in (0,1).  Returns 1 on success, 0 on failure
   (if too many #'s generated) */
int sobolseq_gen(struct sobolseq * sd, double *x)
{
		unsigned c, b, i, sdim;

		if (sd->n == 4294967295U)
				return -1;               /* n == 2^32 - 1 ... we would
										   need to switch to a 64-bit version
										   to generate more terms. */
		c = rightzero32(sd->n++);
		sdim = sd->sdim;
		for (i = 0; i < sdim; ++i) {
				b = sd->b[i];
				if (b >= c) {
						sd->x[i] ^= sd->m[c][i] << (b - c);
						x[i] = ((double) (sd->x[i])) / (1U << (b + 1));
				} else {
						sd->x[i] = (sd->x[i] << (c - b)) ^ sd->m[c][i];
						sd->b[i] = c;
						x[i] = ((double) (sd->x[i])) / (1U << (c + 1));
				}
		}
		return 0;
}


struct sobolseq* sobolseq_init(unsigned sdim)
{
		struct sobolseq* sd;
		if (NULL==(sd=malloc(sizeof(*sd)))) goto eself;

		unsigned i, j;

		if (!sdim || sdim > MAXDIM) goto esdim;

		sd->mdata = (uint32_t *) malloc(sizeof(uint32_t) * (sdim * 32));
		if (NULL == sd->mdata) goto emdata;

		for (j = 0; j < 32; ++j) {
				sd->m[j] = sd->mdata + j * sdim;
				sd->m[j][0] = 1;        /* special-case Sobol sequence */
		}
		for (i = 1; i < sdim; ++i) {
				uint32_t a = sobol_a[i - 1];
				unsigned d = 0, k;

				while (a) {
						++d;
						a >>= 1;
				}
				d--;                    /* d is now degree of poly */

				/* set initial values of m from table */
				for (j = 0; j < d; ++j)
						sd->m[j][i] = sobol_minit[j][i - 1];

				/* fill in remaining values using recurrence */
				for (j = d; j < 32; ++j) {
						a = sobol_a[i - 1];
						sd->m[j][i] = sd->m[j - d][i];
						for (k = 0; k < d; ++k) {
								sd->m[j][i] ^= ((a & 1) * sd->m[j - d + k][i]) << (d - k);
								a >>= 1;
						}
				}
		}

		sd->x = (uint32_t *) malloc(sizeof(uint32_t) * sdim);
		if (NULL==sd->x) goto ex;

		sd->b = (unsigned *) malloc(sizeof(unsigned) * sdim);
		if (NULL==sd->b) goto eb;

		for (i = 0; i < sdim; ++i) {
				sd->x[i] = 0;
				sd->b[i] = 0;
		}

		sd->n = 0;
		sd->sdim = sdim;

		return sd;
		free(sd->b);
eb:
		free(sd->x);
ex:
		free(sd->mdata);
emdata:
esdim:
		free(sd);
eself:
		return NULL;
}


void sobolseq_free(struct sobolseq* sd)
{
		free(sd->mdata);
		free(sd->x);
		free(sd->b);
		free(sd);
}

#ifdef RUNTEST

#include <stdio.h>
#include <assert.h>

int main(void)
{
		printf("testing sobolseq ...");

		int i=0;
		double x[2];
		struct sobolseq* sd;
		assert((sd=sobolseq_init(2)));

		printf("\n");
		for (i=0; i < 1000000; ++i)
				assert(0==sobolseq_gen(sd, x));

		for (i=0; i < 20; ++i) {
				assert(0==sobolseq_gen(sd, x));
				printf("%f, %f\n", x[0], x[1]);
		}

		sobolseq_free(sd);

		printf("PASSED\n");
		return 0;
}

#endif
